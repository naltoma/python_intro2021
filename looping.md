# ループ処理

## iteration (繰り返し処理)とは
![iteration](./figs/iteration.pdf)

これまでに学んできたプログラムにおける処理の流れは、コードを上から順序通りに実行する逐次処理と、条件式に基づき処理すべきブロックを移動する条件分岐がある。基本的にはこれらの組み合わせであらゆるプログラムを記述できるが、(1)ある処理を指定回数繰り返したり、(2)ある集団に対して同じ処理を適用するようなコードを書く際に不便である。例を見てみよう。

```python
# (1) ある処理を指定回数繰り返したい。
# 全く同じ命令を指定回数列挙するだけで良いが、回数毎に書き直すのは不便。
print('ガチャを1回引きました！')
print('ガチャを1回引きました！')
print('ガチャを1回引きました！')
print('ガチャを1回引きました！')

# (2) ある集団に対して同じ処理を適用したい。
# 一部分だけ異なるが、プレイヤー毎に書き直すのは不便。
print('勇者1は経験値10を得た！')
print('勇者2は経験値10を得た！')
print('勇者3は経験値10を得た！')
print('勇者4は経験値10を得た！')
```

上記のようにコードとして書くことは可能だが、何らかの理由でその命令文を修正したい場合には全ての命令文を修正する必要があるし、過不足なく指定回数書いたかどうかを確認することは手間がかかる。

これらの理由から、一般的にプログラミング言語においては「ある一定回数繰り返させたい」場合の処理を **ループ処理や繰り返し処理（looping, iteration）** と呼び、専用の予約語を用いて記述することが多い。Pythonにおいては ``for``, ``while`` の2種類の書き方が提供されている。まずfor文について学んでみよう。

---
## for文の例1
![for1](./figs/for1.pdf)

for文は ``for 変数 in シーケンス:`` という記述で書き始める。forと変数、変数とin、inとシーケンスの間は半角スペースが必要だ。

**シーケンス（sequence）** とは「順番の付いた集合」である。例えば、順番を考慮せず単に集合として「りんご、みかん、バナナ、、、」と果物を集めたものはシーケンスではない。これに対し「1番目にりんご、2番目にみかん、、、」のように順番が付いて並べられているものをシーケンスと呼ぶ。上記のコードでは ``range(4)`` がシーケンスに相当する。range関数の中身を確認するためには一度 ``list型`` に変換すると分かりやすい。次のように実行してみよう。
```python
>>> range(4)
range(0, 4)
>>> list(range(4))
[0, 1, 2, 3]
```
最初のコードがrange関数の結果であり、その結果は ``range(0,4)`` と出力されている。これは **range型オブジェクト** と呼ばれ、そのままでは中身が分かりにくい。この中身を確認しやすくしたのが次の ``list(range(4))`` である。``[]`` は ``list型`` と呼ばれており、中身が ``0, 1, 2, 3`` とint型リテラル0から3まで、合計4個の要素が並んでいる。List型は後日改めて確認するため、ここでは「range関数で引数を自然数kで指定して実行すると、0〜k-1の数字が並んで用意される」ことを覚えよう。

```{note}
世の中では順番を付けて処理する際には「1番目、2番目、、」として1番目から数えることが多い。これに対してプログラミングの世界では、多くの場合0から数える。これはプログラミング言語の慣習のようなものとして覚えておこう。
```

さて、range関数を用いてシーケンスを用意した。このシーケンスに対して、頭から一つずつ要素を取り出し、ブロック内の処理を実行するのがfor文である。Range関数で用意したシーケンスは「0, 1, 2, 3」であるため、最初の値は「0」だ。この値が変数 i に保存された状態でブロック内の処理が実行される。このため、その次は実行させたいブロックを、if文でも書いたようにインデントで指定してコードを書く必要がある。上記コードの例では print(i) となっており、変数iには0が保存されているため、最初は0が出力される。

ここでブロックは終わるため、for文はシーケンス内の次の値を確認する。次の値はint型リテラル1であり、これを変数iに保存してブロック内のコードを実行する。以下同様に、ブロック内のコードを処理し終えると次の値である2を変数iに保存してブロック内のコードを実行する。さらに、ブロック内のコードを処理し終えると次の値である3を変数iに保存してブロック内のコードを実行する。3に対する処理まで実行し終えると、シーケンスに残された値はなく、全ての値に対する実行をし終えていることが分かる。このようにシーケンス内全ての値に対して実行し終えると、for文を終了する（ブロックを抜けて、その下のコードに移動する）ことになる。ここではその下にはもうコードはないため、ここで動作終了となる。

---
## for文の例2
![for2](./figs/for2.pdf)

例1で見た通り、for文はシーケンスに対して一つずつ要素を取り出して、処理を実行する。そのシーケンスを表現するためによく使う型がlistである。listは他のオブジェクトを何でも並べて列挙することができる。

上記コード例では、1番目にint型リテラル80を、2番目にint型リテラル60を、3番目にint型リテラル50を、4番目にstr型リテラルhogegeをカンマ（,）で区切って列挙している。それら全体を ``[`` と ``]``で囲うことでlist型オブジェクトを作成している。なお、ここでは分かりやすいように「1番目」から数え上げたが、Pythonのlistや他の多くの言語における配列と呼ばれるオブジェクトにおいては、殆どの場合「0番目」から数える。例えば次のように実行すると何が出力されるか確認してみよう。
```python
scores = [80, 60, 50, 'hogege']
print(scores[0])
print(scores[1])
print(scores[2])
print(scores[3])
print(scores[4]) # IndexError: list index out of range
```
変数scoresの中に上記コード例1行目のように保存した後で、scores[0] をprint関数で出力させると、80が出力されるはずだ。このように0番目から数え始め、最後は scores[3] に 'hogege' が保存されている。

```{tip}
上記の例で ``scores[4]`` を参照しようとすると ``IndexError: list index out of range`` という応答が返ってくる。これは指定したリストscoresの範囲外のインデックス4が指定されたというエラーだ。scoresは4つの要素を持つリストであるが、各要素は0番目から数えるため最後は3番目までしか存在していない。そのため4番目を指定すると IndexError となる。
```

---
## while文の考えかた
![while1](./figs/while1.pdf)

for文とは別のループ文、while文について学んでみよう。

for文ではリストのように順序付けられた要素集合（シーケンス）を用意した上で、一つずつ要素を取り出してループブロックを実行する。これに対しwhile文では、**ある条件式を満足している間中ループブロックを実行する** ように動作する。

---
## whileの例1
```python
import time

signals = ["🔵", "🟡" ,"🔴"]
i = 0
while(True):
    print(signals[i])
    i += 1
    if( i == 3 ):
        i = 0
    time.sleep(3)

# 終了条件がないため、実行終了したいなら強制終了(ctrl+c)しよう。
```

上記は[e20の学生](https://twitter.com/rienNeVaPlusOne/status/1370384033176195081)が考えてくれたコードだ。実行すると ``🔵🟡🔴`` が繰り返し出力される。以下コードを解説していく。

- 1行目: ``import time``
  - 時刻を扱うPython標準モジュール [time](https://docs.python.org/ja/3.8/library/time.html) を読み込んでいる。
- 3行目: ``signals = ["🔵", "🟡" ,"🔴"]``
  - リストを用意した。🔵は0番目、🟡は1番目、🔴は2番目。
- 4行目: ``i = 0``
  - 一番最初に🔵を出力し、次に🟡、最後に🔴を出力したら、また🔵に戻るようにしたい。これを実現するためのカウンタとして変数iを利用している。具体的には、
    - iの値が0のときは ``signals[0]``を出力し、その次に向けてiを1に上書きする。
    - iの値が1のときは ``signals[1]``を出力し、その次に向けてiを2に上書きする。
    - iの値が2のときは ``signals[2]``を出力し、その次に向けてiを3に上書きする。ここで signals[3] は存在しないため、iを0に上書きし直す。
- 5行目: ``while(True):``
  -

---
## 復習・予習
- 復習
  - 適宜過去資料及び教科書を参照しよう。
- 予習
  - 4.1〜4.1.1 Function Definitions
